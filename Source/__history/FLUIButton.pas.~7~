unit FLUIButton;

interface

uses
  System.SysUtils, System.Classes, Vcl.Controls, Vcl.Graphics, Vcl.StdCtrls,System.Messages,
  System.UITypes, Winapi.Windows, System.Math;

type
  TFLUIButtonType = (fbtContained, fbtOutline, fbtDark, fbtLight);

  TFLUIButton = class(TCustomControl)
  private
    FCaption: string;
    FOnClick: TNotifyEvent;
    FButtonType: TFLUIButtonType;

    FRadius: Integer;
    FContainedColor: TColor;
    FContainedFontColor: TColor;
    FOutlineColor: TColor;
    FOutlineBorderWidth: Integer;
    FDarkColor: TColor;
    FDarkFontColor: TColor;
    FLightColor: TColor;
    FLightFontColor: TColor;
    FHoverColor: TColor;
    FPressedColor: TColor;

    FIsHovering: Boolean;
    FIsPressed: Boolean;

    procedure SetCaption(const Value: string);
    procedure SetButtonType(const Value: TFLUIButtonType);
    procedure SetRadius(const Value: Integer);
    procedure SetContainedColor(const Value: TColor);
    procedure SetContainedFontColor(const Value: TColor);
    procedure SetOutlineColor(const Value: TColor);
    procedure SetOutlineBorderWidth(const Value: Integer);
    procedure SetDarkColor(const Value: TColor);
    procedure SetDarkFontColor(const Value: TColor);
    procedure SetLightColor(const Value: TColor);
    procedure SetLightFontColor(const Value: TColor);
    procedure SetHoverColor(const Value: TColor);
    procedure SetPressedColor(const Value: TColor);

  protected
    procedure Paint; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
    // Assinaturas corrigidas
    procedure CMMouseEnter(var Message: TMessage); message CM_MOUSEENTER;
    procedure CMMouseLeave(var Message: TMessage); message CM_MOUSELEAVE;

  public
    constructor Create(AOwner: TComponent); override;
  published
    property Caption: string read FCaption write SetCaption;
    property ButtonType: TFLUIButtonType read FButtonType write SetButtonType default TFLUIButtonType.fbtContained;

    property Radius: Integer read FRadius write SetRadius default 8;
    property ContainedColor: TColor read FContainedColor write SetContainedColor default clHighlight;
    property ContainedFontColor: TColor read FContainedFontColor write SetContainedFontColor default clHighlightText;
    property OutlineColor: TColor read FOutlineColor write SetOutlineColor default clWindowText;
    property OutlineBorderWidth: Integer read FOutlineBorderWidth write SetOutlineBorderWidth default 1;
    property DarkColor: TColor read FDarkColor write SetDarkColor default clBlack;
    property DarkFontColor: TColor read FDarkFontColor write SetDarkFontColor default clWhite;
    property LightColor: TColor read FLightColor write SetLightColor default clBtnFace;
    property LightFontColor: TColor read FLightFontColor write SetLightFontColor default clBtnText;
    // Default clNone se quiser usar Lighten/Darken por padrão
    property HoverColor: TColor read FHoverColor write SetHoverColor default clHotLight; // ou clNone
    property PressedColor: TColor read FPressedColor write SetPressedColor default clMedGray; // ou clNone

    property Align;
    property Anchors;
    property Constraints;
    property Enabled;
    property Font;
    property ParentFont;
    property ParentShowHint;
    property PopupMenu;
    property ShowHint;
    property Visible;
    property OnClick: TNotifyEvent read FOnClick write FOnClick;
  end;

procedure Register;

implementation

// ... (Suas funções DarkenColor, LightenColor e Register permanecem as mesmas) ...
// Assegure-se que System.Math está na uses da implementation se DarkenColor/LightenColor usarem Max/Min

// Função auxiliar para escurecer a cor (exemplo simples)
function DarkenColor(AColor: TColor; APercent: Byte): TColor;
var
  R, G, B: Byte;
begin
  R := GetRValue(ColorToRGB(AColor));
  G := GetGValue(ColorToRGB(AColor));
  B := GetBValue(ColorToRGB(AColor));
  R := Max(0, R - MulDiv(R, APercent, 100));
  G := Max(0, G - MulDiv(G, APercent, 100));
  B := Max(0, B - MulDiv(B, APercent, 100));
  Result := TColor(RGB(R, G, B));
end;

// Função auxiliar para clarear a cor (exemplo simples)
function LightenColor(AColor: TColor; APercent: Byte): TColor;
var
  R, G, B: Byte;
begin
  R := GetRValue(ColorToRGB(AColor));
  G := GetGValue(ColorToRGB(AColor));
  B := GetBValue(ColorToRGB(AColor));
  R := Min(255, R + MulDiv(255 - R, APercent, 100));
  G := Min(255, G + MulDiv(255 - G, APercent, 100));
  B := Min(255, B + MulDiv(255 - B, APercent, 100));
  Result := TColor(RGB(R, G, B));
end;

procedure Register;
begin
  RegisterComponents('FLUI', [TFLUIButton]);
end;

{ TFLUIButton }

constructor TFLUIButton.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  ControlStyle := ControlStyle + [csOpaque, csClickEvents, csCaptureMouse,
                                  csReplicatable, csTrackMouse]; // Corrigido
  Width := 100;
  Height := 30;
  FCaption := Name;
  FButtonType := TFLUIButtonType.fbtContained;

  FRadius := 8;
  FContainedColor := clHighlight;
  FContainedFontColor := clHighlightText;
  FOutlineColor := clWindowText;
  FOutlineBorderWidth := 1;
  FDarkColor := clBlack;
  FDarkFontColor := clWhite;
  FLightColor := clBtnFace;
  FLightFontColor := clBtnText;
  FHoverColor := clHotLight;   // ou clNone para usar LightenColor por padrão
  FPressedColor := clMedGray; // ou clNone para usar DarkenColor por padrão

  FIsHovering := False;
  FIsPressed := False;
end;

procedure TFLUIButton.CMMouseEnter(var Message: TMessage);
begin
  inherited;
  if not(csDesigning in ComponentState) then
  begin
    if not FIsHovering then
    begin
      FIsHovering := True;
      Invalidate;
    end;
  end;
end;

procedure TFLUIButton.CMMouseLeave(var Message: TMessage);
begin
  inherited;
  if not(csDesigning in ComponentState) then
  begin
    if FIsHovering then
    begin
      FIsHovering := False;
      Invalidate;
    end;
    if FIsPressed then
    begin
      FIsPressed := False;
      Invalidate;
    end;
  end;
end;

procedure TFLUIButton.MouseDown(Button: TMouseButton; Shift: TShiftState;
  X, Y: Integer);
begin
  inherited;
  if Button = mbLeft then
  begin
    if not(csDesigning in ComponentState) then
    begin
      if not FIsPressed then
      begin
        FIsPressed := True;
        Invalidate;
      end;
    end;
  end;
end;

procedure TFLUIButton.MouseUp(Button: TMouseButton; Shift: TShiftState;
  X, Y: Integer);
var
  IsMouseOverControl: Boolean;
begin
  inherited;
  if Button = mbLeft then
  begin
    // O estado FIsPressed deve ser resetado independentemente de estar em design mode ou não,
    // para que o visual do botão volte ao normal.
    // A lógica do clique (FOnClick) é que só deve ocorrer em runtime.
    if FIsPressed then
    begin
      FIsPressed := False;
      IsMouseOverControl := PtInRect(ClientRect, Point(X, Y));
      Invalidate; // Redesenha para remover o estado pressionado

      if not(csDesigning in ComponentState) and IsMouseOverControl and Assigned(FOnClick) then
      begin
        FOnClick(Self);
      end;
    end;
  end;
end;

procedure TFLUIButton.Paint;
var
  Rect: TRect;
  LTextColor, LBackgroundColor, LBorderColor, TempBackgroundColor: TColor;
  LStrokeWidth: Integer;
  LBrushStyle: TBrushStyle;
  OriginalPen: TPen;
  OriginalBrush: TBrush;
  TextFlags: Cardinal;
begin
  OriginalPen := TPen.Create;
  OriginalBrush := TBrush.Create;
  try
    OriginalPen.Assign(Canvas.Pen);
    OriginalBrush.Assign(Canvas.Brush);

    Canvas.Font.Assign(Self.Font);
    Rect := ClientRect;

    LStrokeWidth := 0;
    LBrushStyle := bsSolid;
    LBackgroundColor := clNone;
    TempBackgroundColor := clNone;
    LTextColor := Self.Font.Color; // Default, será sobrescrito
    LBorderColor := clBlack;

    if not Enabled then
    begin
      LBackgroundColor := clBtnShadow;
      LTextColor := clGrayText;
      LBorderColor := clDkGray;
      if FButtonType = fbtOutline then
        LStrokeWidth := FOutlineBorderWidth // Mantém a largura da borda para outline desabilitado
      else
        LStrokeWidth := 0; // Sem borda para outros tipos desabilitados, ou 1 se preferir
    end
    else // Enabled
    begin
      case FButtonType of
        fbtContained:
          begin
            LBackgroundColor := FContainedColor;
            LTextColor := FContainedFontColor;
            LBorderColor := FContainedColor; // Borda da mesma cor do fundo
            LStrokeWidth := 0; // ou 1 se quiser garantir 1px de "borda" da cor do fundo
          end;
        fbtOutline:
          begin
            LBrushStyle := bsClear;
            LBackgroundColor := clNone; // Fundo transparente
            LTextColor := FOutlineColor;
            LBorderColor := FOutlineColor;
            LStrokeWidth := FOutlineBorderWidth;
          end;
        fbtDark:
          begin
            LBackgroundColor := FDarkColor;
            LTextColor := FDarkFontColor;
            LBorderColor := FDarkColor;
            LStrokeWidth := 0;
          end;
        fbtLight:
          begin
            LBackgroundColor := FLightColor;
            LTextColor := FLightFontColor;
            LBorderColor := FLightColor;
            LStrokeWidth := 0;
          end;
      end;

      TempBackgroundColor := LBackgroundColor; // Salva cor base do fundo

      if FIsPressed and not(csDesigning in ComponentState) then
      begin
        if FPressedColor <> clNone then
          TempBackgroundColor := FPressedColor
        else if LBackgroundColor <> clNone then // Só escurece se houver cor de fundo
          TempBackgroundColor := DarkenColor(LBackgroundColor, 20);

        if FButtonType = fbtOutline then
        begin
          if FPressedColor <> clNone then
            LBorderColor := FPressedColor // Usa a cor de Pressionado para a borda/texto
          else
            LBorderColor := DarkenColor(FOutlineColor, 20);
          LTextColor := LBorderColor; // Texto acompanha a cor da borda no outline pressionado
        end;
      end
      else if FIsHovering and not(csDesigning in ComponentState) then
      begin
        if FHoverColor <> clNone then
          TempBackgroundColor := FHoverColor
        else if LBackgroundColor <> clNone then // Só clareia se houver cor de fundo
          TempBackgroundColor := LightenColor(LBackgroundColor, 20);

        if FButtonType = fbtOutline then
        begin
          if FHoverColor <> clNone then
            LBorderColor := FHoverColor // Usa a cor de Hover para a borda/texto
          else
            LBorderColor := LightenColor(FOutlineColor, 20);
          LTextColor := LBorderColor; // Texto acompanha a cor da borda no outline com hover
        end;
      end;
      LBackgroundColor := TempBackgroundColor; // Aplica a cor de fundo modificada
    end; // Fim do Else Enabled

    // Configuração do Brush e Pen para desenhar a forma
    Canvas.Brush.Style := LBrushStyle;
    if LBrushStyle <> bsClear then
      Canvas.Brush.Color := LBackgroundColor
    else
      Canvas.Brush.Color := clNone; // Para bsClear, a cor é irrelevante, mas garante.

    Canvas.Pen.Color := LBorderColor;
    if LStrokeWidth > 0 then
    begin
      Canvas.Pen.Width := LStrokeWidth;
      Canvas.Pen.Style := psSolid;
    end
    else // LStrokeWidth = 0
    begin
      if FButtonType = fbtOutline then // Outline sem largura de borda = sem linha de borda
      begin
        Canvas.Pen.Style := psClear;
      end
      else // Para tipos Contained, Dark, Light sem LStrokeWidth explícito
      begin
        // Define uma "borda" fina da mesma cor do fundo para um acabamento suave,
        // ou nenhuma borda visível se preferir (Canvas.Pen.Style := psClear).
        Canvas.Pen.Color := LBackgroundColor; // Borda da cor do preenchimento
        Canvas.Pen.Width := 1;
        Canvas.Pen.Style := psSolid;
      end;
    end;

    // Desenhar a forma base do botão
    if FRadius > 0 then
      Canvas.RoundRect(Rect.Left, Rect.Top, Rect.Right, Rect.Bottom, FRadius, FRadius)
    else
      Canvas.Rectangle(Rect.Left, Rect.Top, Rect.Right, Rect.Bottom);

    // Desenhar Texto
    Canvas.Brush.Style := bsClear; // Texto não tem fundo próprio
    Canvas.Font.Color := LTextColor;
    TextFlags := DT_CENTER or DT_VCENTER or DT_SINGLELINE or DT_NOCLIP;
    DrawText(Canvas.Handle, PChar(FCaption), Length(FCaption), Rect, TextFlags);

    // Desenhar Foco
    if Focused and not(csDesigning in ComponentState) and Enabled then
    begin
      Canvas.Pen.Color := clGray; // Ou uma cor de foco que combine melhor
      Canvas.Pen.Style := psDot;
      Canvas.Pen.Width := 1; // Garante que a linha pontilhada seja visível
      Canvas.Brush.Style := bsClear;
      var FocusRect := Rect;
      InflateRect(FocusRect, -LStrokeWidth -1, -LStrokeWidth -1); // Ajusta para dentro da borda

      if FRadius > 0 then
         // Raio do foco um pouco menor que o raio do botão e dentro da borda
        Canvas.RoundRect(FocusRect.Left, FocusRect.Top, FocusRect.Right, FocusRect.Bottom,
                         Max(0, FRadius - LStrokeWidth -1 ), Max(0, FRadius - LStrokeWidth -1))
      else
        Canvas.DrawFocusRect(FocusRect); // Foco padrão para retângulos
    end;

  finally
    Canvas.Pen.Assign(OriginalPen);
    Canvas.Brush.Assign(OriginalBrush);
    OriginalPen.Free;
    OriginalBrush.Free;
  end;
end;

// ... (Implementações dos Setters permanecem as mesmas, verificando se chamam Invalidate) ...
// Exemplo SetRadius:
procedure TFLUIButton.SetRadius(const Value: Integer);
begin
  if FRadius <> Value then
  begin
    FRadius := Max(0, Value); // Raio não pode ser negativo
    Invalidate;
  end;
end;

// ... (Implemente todos os outros setters de forma similar, chamando Invalidate) ...
// (As implementações dos seus setters já parecem corretas ao chamar Invalidate)

procedure TFLUIButton.SetCaption(const Value: string);
begin
  if FCaption <> Value then
  begin
    FCaption := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetButtonType(const Value: TFLUIButtonType);
begin
  if FButtonType <> Value then
  begin
    FButtonType := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetContainedColor(const Value: TColor);
begin
  if FContainedColor <> Value then
  begin
    FContainedColor := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetContainedFontColor(const Value: TColor);
begin
  if FContainedFontColor <> Value then
  begin
    FContainedFontColor := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetOutlineColor(const Value: TColor);
begin
  if FOutlineColor <> Value then
  begin
    FOutlineColor := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetOutlineBorderWidth(const Value: Integer);
begin
  if FOutlineBorderWidth <> Value then
  begin
    FOutlineBorderWidth := Max(0, Value);
    Invalidate;
  end;
end;

procedure TFLUIButton.SetDarkColor(const Value: TColor);
begin
  if FDarkColor <> Value then
  begin
    FDarkColor := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetDarkFontColor(const Value: TColor);
begin
  if FDarkFontColor <> Value then
  begin
    FDarkFontColor := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetLightColor(const Value: TColor);
begin
  if FLightColor <> Value then
  begin
    FLightColor := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetLightFontColor(const Value: TColor);
begin
  if FLightFontColor <> Value then
  begin
    FLightFontColor := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetHoverColor(const Value: TColor);
begin
  if FHoverColor <> Value then
  begin
    FHoverColor := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetPressedColor(const Value: TColor);
begin
  if FPressedColor <> Value then
  begin
    FPressedColor := Value;
    Invalidate;
  end;
end;

end.
