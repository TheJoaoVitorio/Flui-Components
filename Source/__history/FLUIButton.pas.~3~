unit FLUIButton;

interface

uses
  System.SysUtils, System.Classes, Vcl.Controls, Vcl.Graphics, Vcl.StdCtrls,
  System.UITypes, Winapi.Windows; // Adicionado Winapi.Windows para PtInRect e outras consts/tipos se necessário

type
  // Adicionado no Passo 1
  TFLUIButtonType = (fbtContained, fbtOutline, fbtDark, fbtLight);

type
  TFLUIButton = class(TCustomControl)
  private
    FCaption: string;
    FOnClick: TNotifyEvent;
    FButtonType: TFLUIButtonType; // Adicionado no Passo 1

    // --- Novas propriedades de estilo (Passo 2) ---
    FRadius: Integer;
    FContainedColor: TColor;
    FContainedFontColor: TColor;
    FOutlineColor: TColor;
    FOutlineBorderWidth: Integer;
    FDarkColor: TColor;
    FDarkFontColor: TColor;
    FLightColor: TColor;
    FLightFontColor: TColor;
    FHoverColor: TColor;
    FPressedColor: TColor;
    // --- Fim das novas propriedades de estilo ---

    // --- Novas variáveis de estado (Passo 3) ---
    FIsHovering: Boolean;
    FIsPressed: Boolean;
    // --- Fim das variáveis de estado ---

    procedure SetCaption(const Value: string);
    procedure SetButtonType(const Value: TFLUIButtonType); // Adicionado no Passo 1
    // --- Setters para as novas propriedades (Passo 2) ---
    procedure SetRadius(const Value: Integer);
    procedure SetContainedColor(const Value: TColor);
    procedure SetContainedFontColor(const Value: TColor);
    procedure SetOutlineColor(const Value: TColor);
    procedure SetOutlineBorderWidth(const Value: Integer);
    procedure SetDarkColor(const Value: TColor);
    procedure SetDarkFontColor(const Value: TColor);
    procedure SetLightColor(const Value: TColor);
    procedure SetLightFontColor(const Value: TColor);
    procedure SetHoverColor(const Value: TColor);
    procedure SetPressedColor(const Value: TColor);
    // --- Fim dos setters ---

  protected
    procedure Paint; override; // Modificado significativamente no Passo 3
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override; // Modificado no Passo 4
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;   // Modificado no Passo 4
    // --- Adicionar declarações (Passo 4) ---
    procedure MouseEnter; message CM_MOUSEENTER;
    procedure MouseLeave; message CM_MOUSELEAVE;
    // --- Fim das declarações ---

  public
    constructor Create(AOwner: TComponent); override;
  published
    property Caption: string read FCaption write SetCaption;
    property ButtonType: TFLUIButtonType read FButtonType write SetButtonType default TFLUIButtonType.fbtContained; // Adicionado no Passo 1

    // --- Novas propriedades de estilo (Passo 2) ---
    property Radius: Integer read FRadius write SetRadius default 8;
    property ContainedColor: TColor read FContainedColor write SetContainedColor default clHighlight;
    property ContainedFontColor: TColor read FContainedFontColor write SetContainedFontColor default clHighlightText;
    property OutlineColor: TColor read FOutlineColor write SetOutlineColor default clWindowText;
    property OutlineBorderWidth: Integer read FOutlineBorderWidth write SetOutlineBorderWidth default 1;
    property DarkColor: TColor read FDarkColor write SetDarkColor default clBlack;
    property DarkFontColor: TColor read FDarkFontColor write SetDarkFontColor default clWhite;
    property LightColor: TColor read FLightColor write SetLightColor default clBtnFace;
    property LightFontColor: TColor read FLightFontColor write SetLightFontColor default clBtnText;
    property HoverColor: TColor read FHoverColor write SetHoverColor default clHotLight;
    property PressedColor: TColor read FPressedColor write SetPressedColor default clMedGray;
    // --- Fim das novas propriedades de estilo ---

    property Align;
    property Anchors;
    property Constraints;
    property Enabled;
    property Font;
    property ParentFont;
    property ParentShowHint;
    property PopupMenu;
    property ShowHint;
    property Visible;
    property OnClick: TNotifyEvent read FOnClick write FOnClick;
  end;

procedure Register;

implementation

uses System.Math; // Para Max e Min, se usar TColorRec.Lighten/Darken ou similar

// Função auxiliar para escurecer a cor (exemplo simples)
function DarkenColor(AColor: TColor; APercent: Byte): TColor;
var
  R, G, B: Byte;
begin
  R := GetRValue(ColorToRGB(AColor));
  G := GetGValue(ColorToRGB(AColor));
  B := GetBValue(ColorToRGB(AColor));
  R := Max(0, R - MulDiv(R, APercent, 100));
  G := Max(0, G - MulDiv(G, APercent, 100));
  B := Max(0, B - MulDiv(B, APercent, 100));
  Result := TColor(RGB(R, G, B));
end;

// Função auxiliar para clarear a cor (exemplo simples)
function LightenColor(AColor: TColor; APercent: Byte): TColor;
var
  R, G, B: Byte;
begin
  R := GetRValue(ColorToRGB(AColor));
  G := GetGValue(ColorToRGB(AColor));
  B := GetBValue(ColorToRGB(AColor));
  R := Min(255, R + MulDiv(255 - R, APercent, 100));
  G := Min(255, G + MulDiv(255 - G, APercent, 100));
  B := Min(255, B + MulDiv(255 - B, APercent, 100));
  Result := TColor(RGB(R, G, B));
end;


procedure Register;
begin
  RegisterComponents('FLUI', [TFLUIButton]);
end;

{ TFLUIButton }

constructor TFLUIButton.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  // Modificado no Passo 4: Adicionado csMouseEnterEvents e csMouseLeaveEvents
  ControlStyle := ControlStyle + [csOpaque, csClickEvents, csCaptureMouse, csMouseEnterEvents, csMouseLeaveEvents, csReplicatable];
  Width := 100;
  Height := 30;
  FCaption := Name;
  FButtonType := TFLUIButtonType.fbtContained; // Inicializado no Passo 1

  // --- Inicialização das novas propriedades (Passo 2) ---
  FRadius := 8;
  FContainedColor := clHighlight;
  FContainedFontColor := clHighlightText;
  FOutlineColor := clWindowText;
  FOutlineBorderWidth := 1;
  FDarkColor := clBlack;
  FDarkFontColor := clWhite;
  FLightColor := clBtnFace;
  FLightFontColor := clBtnText;
  FHoverColor := clHotLight; // Você pode querer definir clNone e usar Lighten/Darken
  FPressedColor := clMedGray; // Você pode querer definir clNone e usar Lighten/Darken
  // --- Fim da inicialização ---

  // --- Inicialização das variáveis de estado (Passo 3) ---
  FIsHovering := False;
  FIsPressed := False;
  // --- Fim da inicialização ---
end;

// Implementações dos Manipuladores de Eventos do Mouse (Passo 4)
procedure TFLUIButton.MouseEnter;
begin
  inherited;
  if not (csDesigning in ComponentState) then // Não executa em design-time
  begin
    if not FIsHovering then
    begin
      FIsHovering := True;
      Invalidate;
    end;
  end;
end;

procedure TFLUIButton.MouseLeave;
begin
  inherited;
   if not (csDesigning in ComponentState) then // Não executa em design-time
  begin
    if FIsHovering then
    begin
      FIsHovering := False;
      Invalidate;
    end;
    if FIsPressed then // Se o mouse sair enquanto pressionado
    begin
      FIsPressed := False;
      Invalidate;
    end;
  end;
end;

procedure TFLUIButton.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  inherited;
  if Button = mbLeft then
  begin
    if not (csDesigning in ComponentState) then // Não executa em design-time
    begin
      if not FIsPressed then
      begin
        FIsPressed := True;
        Invalidate;
      end;
    end;
  end;
end;

procedure TFLUIButton.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  IsMouseOverControl: Boolean;
begin
  inherited;
  if Button = mbLeft then
  begin
    if not (csDesigning in ComponentState) then // Não executa em design-time
    begin
      if FIsPressed then
      begin
        FIsPressed := False;
        IsMouseOverControl := PtInRect(ClientRect, Point(X, Y));
        Invalidate;

        if IsMouseOverControl and Assigned(FOnClick) then
        begin
          FOnClick(Self);
        end;
      end;
    end;
  end;
end;

// Método Paint (Passo 3)
procedure TFLUIButton.Paint;
var
  Rect: TRect;
  LTextColor, LBackgroundColor, LBorderColor, TempBackgroundColor: TColor;
  LStrokeWidth: Integer;
  LBrushStyle: TBrushStyle;
  OriginalPen: TPen;
  OriginalBrush: TBrush;
  TextFlags: Cardinal;
begin
  OriginalPen := TPen.Create;
  OriginalBrush := TBrush.Create;
  try
    OriginalPen.Assign(Canvas.Pen);
    OriginalBrush.Assign(Canvas.Brush);

    Canvas.Font.Assign(Self.Font);
    Rect := ClientRect;

    LStrokeWidth := 0;
    LBrushStyle := bsSolid;
    LBackgroundColor := clNone; // Cor de fundo base
    TempBackgroundColor := clNone; // Cor de fundo para hover/press
    LTextColor := Self.Font.Color;
    LBorderColor := clBlack; // Cor de borda padrão

    if not Enabled then
    begin
      LBackgroundColor := clBtnShadow;
      LTextColor := clGrayText;
      LBorderColor := clDkGray;
      if FButtonType = fbtOutline then
         LStrokeWidth := FOutlineBorderWidth;
    end
    else
    begin
      case FButtonType of
        fbtContained:
          begin
            LBackgroundColor := FContainedColor;
            LTextColor := FContainedFontColor;
            LBorderColor := FContainedColor;
          end;
        fbtOutline:
          begin
            LBrushStyle := bsClear;
            LBackgroundColor := clNone; // Fundo transparente
            LTextColor := FOutlineColor;
            LBorderColor := FOutlineColor;
            LStrokeWidth := FOutlineBorderWidth;
          end;
        fbtDark:
          begin
            LBackgroundColor := FDarkColor;
            LTextColor := FDarkFontColor;
            LBorderColor := FDarkColor;
          end;
        fbtLight:
          begin
            LBackgroundColor := FLightColor;
            LTextColor := FLightFontColor;
            LBorderColor := FLightColor;
          end;
      end;

      // Guarda a cor de fundo original antes de aplicar hover/press
      TempBackgroundColor := LBackgroundColor;

      if FIsPressed and not (csDesigning in ComponentState) then
      begin
        if FPressedColor <> clNone then
          TempBackgroundColor := FPressedColor
        else
          TempBackgroundColor := DarkenColor(LBackgroundColor, 20); // Escurece em 20%

        if FButtonType = fbtOutline then
        begin
           if FPressedColor <> clNone then
             LBorderColor := FPressedColor
           else
             LBorderColor := DarkenColor(FOutlineColor, 20);
           LTextColor := LBorderColor;
        end;
      end
      else if FIsHovering and not (csDesigning in ComponentState) then
      begin
        if FHoverColor <> clNone then
          TempBackgroundColor := FHoverColor
        else
          TempBackgroundColor := LightenColor(LBackgroundColor, 20); // Clareia em 20%

        if FButtonType = fbtOutline then
        begin
          if FHoverColor <> clNone then
            LBorderColor := FHoverColor
          else
            LBorderColor := LightenColor(FOutlineColor, 20);
          LTextColor := LBorderColor;
        end;
      end;
      // Atribui a cor de fundo modificada (ou original se não houver hover/press)
      LBackgroundColor := TempBackgroundColor;

    end;

    Canvas.Brush.Style := LBrushStyle;
    if LBrushStyle <> bsClear then
      Canvas.Brush.Color := LBackgroundColor;

    Canvas.Pen.Color := LBorderColor;
    if LStrokeWidth > 0 then
    begin
      Canvas.Pen.Width := LStrokeWidth;
      Canvas.Pen.Style := psSolid;
    end
    else
    begin
      if LBrushStyle = bsClear then // Outline sem borda (não faz muito sentido, mas para cobrir)
         Canvas.Pen.Style := psClear
      else // Para Contained, Dark, Light, a borda tem a cor do fundo
         Canvas.Pen.Color := LBackgroundColor;
    end;

    if FRadius > 0 then
      Canvas.RoundRect(Rect.Left, Rect.Top, Rect.Right, Rect.Bottom, FRadius, FRadius)
    else
      Canvas.FillRect(Rect); // Se raio for 0, usa FillRect e desenha borda retangular se necessário

    // Se raio for 0 e houver borda definida (ex: Outline), desenha retângulo para a borda
    if (FRadius = 0) and (LStrokeWidth > 0) and (LBrushStyle = bsClear) then // Caso específico do Outline sem raio
    begin
        Canvas.Pen.Color := LBorderColor;
        Canvas.Pen.Width := LStrokeWidth;
        Canvas.FrameRect(Rect);
    end
    else if (FRadius = 0) and (LStrokeWidth > 0) then // Para outros tipos com borda e sem raio
    begin
        // A borda já foi "desenhada" pelo FillRect se Pen.Color = BackgroundColor
        // Se Pen.Color for diferente (ex: Outline com BackgroundColor e BorderColor diferentes), precisa de FrameRect
        // Mas a lógica atual já define Pen.Color = LBackgroundColor para os tipos não-Outline sem borda explícita
    end;


    Canvas.Brush.Style := bsClear;
    Canvas.Font.Color := LTextColor;

    TextFlags := DT_CENTER or DT_VCENTER or DT_SINGLELINE or DT_NOCLIP;
    DrawText(Canvas.Handle, PChar(FCaption), Length(FCaption), Rect, TextFlags);

    if Focused and not (csDesigning in ComponentState) and Enabled then
    begin
      // Desenha um retângulo de foco sutil, respeitando o arredondamento
      Canvas.Pen.Color := clGray; // Ou uma cor de foco mais apropriada
      Canvas.Pen.Style := psDot;
      Canvas.Brush.Style := bsClear;
      if FRadius > 0 then
        Canvas.RoundRect(Rect.Left+1, Rect.Top+1, Rect.Right-1, Rect.Bottom-1, FRadius-1, FRadius-1)
      else
        Canvas.DrawFocusRect(Rect); // Foco padrão para retângulos
    end;

  finally
    Canvas.Pen.Assign(OriginalPen);
    Canvas.Brush.Assign(OriginalBrush);
    OriginalPen.Free;
    OriginalBrush.Free;
  end;
end;

// Implementações dos Setters (Passo 2 e Passo 1)
procedure TFLUIButton.SetCaption(const Value: string);
begin
  if FCaption <> Value then
  begin
    FCaption := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetButtonType(const Value: TFLUIButtonType);
begin
  if FButtonType <> Value then
  begin
    FButtonType := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetRadius(const Value: Integer);
begin
  if FRadius <> Value then
  begin
    FRadius := Max(0, Value); // Raio não pode ser negativo
    Invalidate;
  end;
end;

procedure TFLUIButton.SetContainedColor(const Value: TColor);
begin
  if FContainedColor <> Value then
  begin
    FContainedColor := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetContainedFontColor(const Value: TColor);
begin
  if FContainedFontColor <> Value then
  begin
    FContainedFontColor := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetOutlineColor(const Value: TColor);
begin
  if FOutlineColor <> Value then
  begin
    FOutlineColor := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetOutlineBorderWidth(const Value: Integer);
begin
  if FOutlineBorderWidth <> Value then
  begin
    FOutlineBorderWidth := Max(0, Value); // Largura não pode ser negativa
    Invalidate;
  end;
end;

procedure TFLUIButton.SetDarkColor(const Value: TColor);
begin
  if FDarkColor <> Value then
  begin
    FDarkColor := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetDarkFontColor(const Value: TColor);
begin
  if FDarkFontColor <> Value then
  begin
    FDarkFontColor := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetLightColor(const Value: TColor);
begin
  if FLightColor <> Value then
  begin
    FLightColor := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetLightFontColor(const Value: TColor);
begin
  if FLightFontColor <> Value then
  begin
    FLightFontColor := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetHoverColor(const Value: TColor);
begin
  if FHoverColor <> Value then
  begin
    FHoverColor := Value;
    Invalidate;
  end;
end;

procedure TFLUIButton.SetPressedColor(const Value: TColor);
begin
  if FPressedColor <> Value then
  begin
    FPressedColor := Value;
    Invalidate;
  end;
end;

end.
