unit FLUI.ContainerGridLayout;

interface

uses
  FLUI.Classes,
  System.Classes, System.SysUtils, System.Math,
  Vcl.Controls, Vcl.ExtCtrls;

type
  TFLUIContainerGridLayout = class(TCustomPanel)
  private
    FGridLayout: TFLUIGridLayoutSettings;
    procedure SetGridLayout(const Value: TFLUIGridLayoutSettings);
    procedure LayoutSettingsChanged(Sender: TObject);
  protected
    procedure Resize; override;
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure UpdateLayout;
  published
    property GridLayout: TFLUIGridLayoutSettings read FGridLayout write SetGridLayout;

    property Align;
    property Anchors;
    property BevelOuter;
    property Constraints;
    property Padding;
    property ParentColor;
    property ParentBackground;
    property Visible;
  end;

procedure Register;

implementation

{ TFLUIContainerGridLayout }

constructor TFLUIContainerGridLayout.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);

  FGridLayout := TFLUIGridLayoutSettings.Create;

  FGridLayout.OnChange := LayoutSettingsChanged;
end;

destructor TFLUIContainerGridLayout.Destroy;
begin
  FGridLayout.Free;
  inherited Destroy;
end;

procedure TFLUIContainerGridLayout.LayoutSettingsChanged(Sender: TObject);
begin
  UpdateLayout;
end;

procedure TFLUIContainerGridLayout.Resize;
begin
  inherited;
  UpdateLayout;
end;

procedure TFLUIContainerGridLayout.Notification(AComponent: TComponent; Operation: TOperation);
begin
  inherited;
  if (Operation = opInsert) or (Operation = opRemove) then
  begin
    if AComponent.Owner = Self then
      UpdateLayout;
  end;
end;

procedure TFLUIContainerGridLayout.SetGridLayout(const Value: TFLUIGridLayoutSettings);
begin

  FGridLayout.Assign(Value);
end;

procedure TFLUIContainerGridLayout.UpdateLayout;
var
  I, Col, Row, VisibleControlIndex, ColumnCount, ItemW, ItemH: Integer;
  X, Y: Integer;
  Child: TControl;
begin
  if (csLoading in ComponentState) or (FGridLayout = nil) then
    Exit;


  ColumnCount := Trunc((Width - Padding.Left - Padding.Right + FGridLayout.Gap) / (FGridLayout.ItemWidth + FGridLayout.Gap));
  if ColumnCount > FGridLayout.MaxColumns then
    ColumnCount := FGridLayout.MaxColumns;
  if ColumnCount < 1 then
    ColumnCount := 1;


  if ColumnCount = 1 then
    ItemW := Width - Padding.Left - Padding.Right
  else
    ItemW := Trunc((Width - Padding.Left - Padding.Right - (ColumnCount - 1) * FGridLayout.Gap) / ColumnCount);


  VisibleControlIndex := -1;
  for I := 0 to ControlCount - 1 do
  begin
    Child := Controls[I];

    if (Child is TWinControl) and Child.Visible then
    begin
      Inc(VisibleControlIndex);

      Col := VisibleControlIndex mod ColumnCount;
      Row := VisibleControlIndex div ColumnCount;


      if (ColumnCount = 1) and FGridLayout.SingleColumnAsRow then
        ItemH := FGridLayout.RowItemHeight
      else
        ItemH := FGridLayout.ItemHeight;


      X := Padding.Left + Col * (ItemW + FGridLayout.Gap);
      Y := Padding.Top + Row * (ItemH + FGridLayout.Gap);


      Child.SetBounds(X, Y, ItemW, ItemH);
    end;
  end;
end;

procedure Register;
begin
  RegisterComponents('FLUI', [TFLUIContainerGridLayout]);
end;

end.
